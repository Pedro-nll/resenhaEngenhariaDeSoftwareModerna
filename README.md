O livro *Engenharia de Software Moderna*, de Marco Tulio Valente, nos capítulos 6 e 7, aborda padrões de projeto e arquitetura de software, temas fundamentais para o desenvolvimento de software. O capítulo 6 apresenta os padrões de projeto mais utilizados e explicando quando e como aplicá-los. Já o capítulo 7 discute os padrões arquiteturais mais adotados atualemnte, aprofundando em seu funcionamento e destacando suas principais características.

No capítulo 6, o autor explora padrões de projeto amplamente usados, como 'Factory', "Singleton", "Adapter", "Facede", "Observer", entre outros. Depois de contextualizar o padrão e o problema que ele tenta resolver, apresenta claramente o padrão como solução. Parindo do entendimento de uma uma situação que o padrão será útil, fica mais fácil a identificação de um problema e, por fim, entender a solução com base no padrão discutido.

Nos meus estudos prévios, fiquei sempre apegado aos princípios SOLID e fascinado com a aplicabilidade deles para a melhoria da estrutura dos sistemas independente de seus contextos. Diante desse cenário, ver o autor destacando a importância dos princípios, por exemplo, ao falar de Factories, demonstrando como o contexto viola o Open/Closed, e como solução, o padrão de projeto resolve esse problema, alinhando-se ao princípio Dependency Inversion foi muito gratificante. Ter em mente a separação de dependencias e buscar sempre que sejam dependencias de componentes abstratos e não concretos já é uma preocupação constante, mas ter um padrão que garanta isso é de suma importância.

Além de explicar como e quando aplicar cada padrão, o autor dedica uma seção para alertar sobre os momentos em que esses padrões não devem ser utilizados. Embora eles aumentem a abstração, também adicionam complexidade ao desenvolvimento. O autor destaca a importância de questionar se o padrão realmente trará benefícios ao código. Por exemplo, antes de adotar o padrão Strategy, é crucial avaliar se há uma necessidade real de utilizar algoritmos alternativos. Caso contrário, a implementação pode ser realizada diretamente na classe original, evitando a criação de arquivos desnecessários.

No capítulo 7, o autor começa introduzindo o conceito de arquitetura de software, para depois abordar padrões específicos, como Arquitetura em Camadas, MVC, Microsserviços, Filas de Mensagens e Publish/Subscribe. O texto oferece duas definições de arquitetura de software. A primeira se concentra em componentes de maior escala, como pacotes e módulos, destacando a importância de alinhar esses componentes com os objetivos do sistema. A segunda, atribuída a Ralph Johnson, define a arquitetura como um conjunto de decisões de design críticas e difíceis de reverter, como a escolha da linguagem de programação e do banco de dados, decisões essas que afetam diretamente a evolução do sistema.

A discussão sobre arquitetura em camadas é enriquecida com exemplos relacionados a protocolos de rede, culminando em uma explicação sobre a arquitetura de três camadas: cliente, servidor e banco de dados. Nesse ponto, o autor utiliza diagramas para ilustrar a comunicação entre as camadas, facilitando a compreensão.

Embora o conteúdo sobre arquitetura seja excelente, algumas abordagens fazem referência a padrões da década de 1990 ou anteriores, com exceção da parte sobre microsserviços. Estruturas como cliente, servidor e banco de dados ainda são comuns, mas uma discussão mais aprofundada sobre serviços em nuvem poderia ter sido mais relevante. Mesmo assim, o livro oferece um resumo abrangente e útil de todas as arquiteturas abordadas.